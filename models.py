"""Pydantic models that mirror the Supabase schema.

* `orm_mode` is not set as it's not needed in the Supabase SDK.
* All fields have `Field` with a clear `description` for better usability with **Structured Output** like Gemini.
* Type hints are simplified to `int` / `str` / `bool` / `dict` for practical use.
  `int4range` is treated as a string like "[191,196)" (conversion should be done on the SDK side).
"""

from __future__ import annotations

from typing import Dict, Optional

from pydantic import BaseModel, Field


# ---------------------------------------------------------------------------
# Top‑level: tests
# ---------------------------------------------------------------------------
class TestForm(BaseModel):
    id: Optional[int] = Field(
        None, description="primary key – generated by the database (BIGSERIAL)"
    )
    name: str = Field(
        ..., description="Name / Identifier title (e.g., 'TOEIC 2023 Form A')"
    )


# ---------------------------------------------------------------------------
# sections
# ---------------------------------------------------------------------------
class Section(BaseModel):
    id: Optional[int] = Field(None, description="primary key – BIGSERIAL")
    test_id: int = Field(..., description="FK → tests.id")
    label: str = Field(..., description="Section name (Reading, Listening …)")
    order_no: int = Field(..., description="Order within the test 1,2,3…")


# ---------------------------------------------------------------------------
# parts
# ---------------------------------------------------------------------------
class Part(BaseModel):
    id: Optional[int] = Field(None, description="primary key – BIGSERIAL")
    section_id: int = Field(..., description="FK → sections.id")
    label: str = Field(..., description="Part name (e.g., Part 5)")
    question_format: str = Field(
        ..., description="Question format (short_blank / long_blank / comprehension etc.)"
    )
    order_no: int = Field(..., description="Order within the section 1,2,3…")


# ---------------------------------------------------------------------------
# passage_sets
# ---------------------------------------------------------------------------
class PassageSet(BaseModel):
    id: Optional[int] = Field(None, description="primary key - BIGSERIAL")
    part_id: int = Field(..., description="FK → parts.id")
    order_no: int = Field(..., description="Order within the Part 1,2,3…")
    question_range: str = Field(
        ..., description="String representation of the question number range (int4range), e.g., '[191,196)')"
    )
    title: Optional[str] = Field(None, description="Heading or subject (optional)")
    metadata: Optional[Dict] = Field(
        None, description="Free-form additional metadata (JSONB)"
    )


# ---------------------------------------------------------------------------
# passages
# ---------------------------------------------------------------------------
class Passage(BaseModel):
    id: Optional[int] = Field(None, description="primary key – BIGSERIAL")
    passage_set_id: int = Field(..., description="FK → passage_sets.id")
    order_no: int = Field(..., description="Order within the Passage Set 1,2,3…")
    body: str = Field(..., description="Body text (Markdown / plain text)")
    metadata: Optional[Dict] = Field(
        None, description="JSONB such as page number, bbox, audio_url, etc."
    )


# ---------------------------------------------------------------------------
# questions
# ---------------------------------------------------------------------------
class Question(BaseModel):
    id: Optional[int] = Field(None, description="primary key – BIGSERIAL")
    passage_set_id: int = Field(..., description="FK → passage_sets.id")
    part_id: int = Field(..., description="Redundant storage: FK → parts.id")
    number: int = Field(..., description="Question number 101, 132… (unique within the Part)")
    blank_index: Optional[int] = Field(
        None, description="Order of the blank within the Passage. Null for non-blank questions."
    )
    stem: str = Field(..., description="Question stem or sentence with a blank")
    answer_explanation: Optional[str] = Field(
        None, description="Explanation / rationale text (optional)"
    )
    difficulty: Optional[str] = Field(
        None, description="Difficulty tag (easy/medium/hard etc.)"
    )
    attributes: Optional[Dict] = Field(
        None, description="Extended attributes such as topic, cefr_level (JSONB)"
    )


# ---------------------------------------------------------------------------
# choices
# ---------------------------------------------------------------------------
class Choice(BaseModel):
    id: Optional[int] = Field(None, description="primary key – BIGSERIAL")
    question_id: int = Field(..., description="FK → questions.id")
    label: str = Field(..., description="Choice label (A/B/C/D …)")
    content: str = Field(..., description="Choice text")
    is_correct: bool = Field(..., description="Correct answer flag")


# ---------------------------------------------------------------------------
# tags & mapping table (question_tags)
# ---------------------------------------------------------------------------
class Tag(BaseModel):
    id: Optional[int] = Field(None, description="primary key – BIGSERIAL")
    level1: str = Field(..., description="Skill Level 1")
    level2: Optional[str] = Field(None, description="Category Level 2")
    level3: Optional[str] = Field(None, description="Sub‑category Level 3")


class QuestionTag(BaseModel):
    question_id: int = Field(..., description="FK → questions.id")
    tag_id: int = Field(..., description="FK → tags.id")